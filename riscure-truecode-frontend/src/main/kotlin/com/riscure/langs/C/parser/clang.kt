package com.riscure.langs.c

import arrow.core.*
import com.riscure.tc.codeanalysis.clang.ast.loader.ClangParsingResult
import com.riscure.tc.codeanalysis.clang.compiler2.loader.CompileCommandMapping
import org.bytedeco.javacpp.*
import org.bytedeco.llvm.clang.*
import org.bytedeco.llvm.global.clang
import org.bytedeco.llvm.global.clang.*
import org.bytedeco.llvm.global.clang.clang_parseTranslationUnit2 as clang_parse
import java.io.File
import java.util.*

/**
 * This implements the parser interface using the Bytedeco library to call
 * into libclang to parse a C file.
 *
 * This is *not* thread-safe.
 */
class ClangParser(val ccMap : CompileCommandMapping = CompileCommandMapping()): Parser {

    override fun parse(file: File): Result<TranslationUnit> {
        val args: Array<String> = arrayOf("")

        // We allocate the arguments.
        val c_index: CXIndex = clang.clang_createIndex(0, 0)
        val c_tu = CXTranslationUnit()
        val c_sourceFile = BytePointer(file.absolutePath.toString())
        val c_arg_pointers = args.map { BytePointer(it) }
        val c_args = PointerPointer<BytePointer>(args.size.toLong())
        val c_parseOptions = clang.CXTranslationUnit_SingleFileParse

        c_arg_pointers.forEach { c_args.put(it) }

        // Define the deallocator
        fun free() {
            clang.clang_disposeIndex(c_index)
            clang.clang_disposeTranslationUnit(c_tu)
            c_sourceFile.close()
            c_arg_pointers.forEach { it.deallocate() }
            c_args.deallocate()
        }

        // Call into libclang via bytedeco
        val code: Int = clang_parse(c_index, c_sourceFile, c_args, args.size, null, 0, c_parseOptions, c_tu)

        try {
            // Interpret the result code generated by clang:
            val result = ClangParsingResult.fromCode(code)
            return if (result != ClangParsingResult.Success) {
                result.message.left()
            } else {
                // transform the translation unit outputted by clang to a real Java AST object
                val c_tuCursor = clang.clang_getTranslationUnitCursor(c_tu)
                return c_tuCursor.asTranslationUnit()
            }
        } finally { free() }
    }
}

// We define extension functions for CXCursors that translate to the AST
// All these translations are partial, because they validate structure that is
// not apparent through the visitor API of libclang.

fun CXCursor.children(): List<CXCursor> {
    val cs = mutableListOf<CXCursor>()

    clang_visitChildren(
        this,
        object: CXCursorVisitor() {
            override fun call(self: CXCursor?, parent: CXCursor?, p2: CXClientData?): Int {
                cs.add(self!!)
                return CXChildVisit_Continue
            }
        },
        null)

    return cs
}

// getters

fun CXCursor.kind() = clang_getCursorKind(this)
fun CXCursor.spelling(): String = clang_getCursorSpelling(this).string

// utility functions
fun <T> CXCursor.ifKind(k: Int, expectation: String, whenMatch: () -> Result<T>): Result<T> {
    if (kind() != k) {
        return "Expected ${expectation}. Got cursor of kind ${kind()}".left()
    }

    return whenMatch()
}

// AST translation functions

fun CXCursor.asTranslationUnit(): Result<TranslationUnit> {
    if (this.kind() != CXCursor_TranslationUnit) {
        return "Expected translation unit, got cursor of kind $this.kind()".left()
    }

    return this.children()
        .map { it.asGlobalDecl() }
        .sequenceEither()
        .map { TranslationUnit(it) }
}

fun CXCursor.asGlobalDecl(): Result<GlobalDecl> {
    return when (this.kind()) {
        CXCursor_FunctionDecl -> this.asFunctionDecl()
        else -> "Expected global declaration".left()
    }
}

fun CXCursor.getResultType(): Result<Type> {
    val typ = clang_getCursorResultType(this)
    return typ.asType()
}

fun CXCursor.getParameters(): Result<List<Param>> {
    val nargs = clang_Cursor_getNumArguments(this)
    return (0 until nargs)
        .map { clang_Cursor_getArgument(this, it) }
        .map { it.asParam() }
        .sequenceEither()
}

fun CXCursor.getFunctionBody(): Result<Stmt> {
    val children = this.children()
    if (children.size != 1) {
        return "Expected single child representing function body, got ${children.size} children.".left()
    }

    return children[0].asStmt()
}

fun CXCursor.asFunctionDecl(): Result<GlobalDecl.Fun> {
    if (kind() != CXCursor_FunctionDecl) {
        return "Expected function declaration, got cursor of kind ${kind()}".left()
    }

    val nargs = clang_Cursor_getNumArguments(this)
    return (
        this.getResultType().flatMap { resultType ->
        this.getFunctionBody().flatMap { body ->
        this.getParameters().map { params ->
            GlobalDecl.Fun(
                false,  // TODO
                spelling(),
                resultType,
                params,
                false, // TODO
                listOf(),     // TODO
                body
            )
        }}}
    )
}

fun CXCursor.asParam(): Result<Param> {
    if (kind() != CXCursor_ParmDecl) {
        return "Exepected parameter declaration".left()
    }

    return clang_getCursorType(this)
        .asType()
        .map { type -> Param(spelling(), type) }
}

fun CXCursor.asStmt(): Result<Stmt> {
    if (clang_isStatement(kind()) == 0) {
        return "Expected statement, got cursor of kind ${kind()}".left()
    }

    return when (kind()) {
        CXCursor_DeclStmt -> asDecl()
        CXCursor_CompoundStmt -> asBlock()
        else -> "Unrecognized statement of cursor kind ${kind()}".left()
    }
}

fun CXCursor.asDecl(): Result<Stmt.Decl> = ifKind(CXCursor_DeclStmt, "declaration statement") {
    val children = this.children()

    if (children.size != 1) {
        "Expected single declaration, got ${children.size} children.".left()
    } else {
        this.children()[0].asVarDecl()
    }
}

fun CXCursor.asVarDecl(): Result<Stmt.Decl> = ifKind(CXCursor_VarDecl, "variable declaration") {
    clang_getCursorType(this)
        .asType()
        .map { type ->
            Stmt.Decl(this.spelling(), type)
        }
}

fun CXCursor.asBlock(): Result<Stmt.Block> = ifKind(CXCursor_CompoundStmt, "block") {
    children()
        .map { it.asStmt() }
        .sequenceEither()
        .map { Stmt.Block(it) }
}

// CXType extensions

fun CXType.asType(): Result<Type> =
    when (this.kind()) {
        CXType_Void -> Type.Void().right()
        CXType_Bool -> Type.Int(IKind.IBoolean).right()
        CXType_Char_U -> Type.Int(IKind.IUChar).right() // correct?
        CXType_UChar  -> Type.Int(IKind.IUChar).right() // correct?
        CXType_UShort  -> Type.Int(IKind.IUShort).right()
        CXType_UInt  -> Type.Int(IKind.IUInt).right()
        CXType_ULong  -> Type.Int(IKind.IULong).right()
        CXType_ULongLong  -> Type.Int(IKind.IULongLong).right()
        CXType_Char_S -> Type.Int(IKind.IChar).right() // correct?
        CXType_SChar -> Type.Int(IKind.ISChar).right() // correct?
        CXType_Short -> Type.Int(IKind.IShort).right()
        CXType_Int -> Type.Int(IKind.IInt).right()
        CXType_Long -> Type.Int(IKind.ILong).right()
        CXType_LongLong -> Type.Int(IKind.ILongLong).right()

        CXType_Float -> Type.Float(FKind.FFloat).right()
        CXType_Double -> Type.Float(FKind.FDouble).right()
        CXType_LongDouble -> Type.Float(FKind.FLongDouble).right()

        CXType_Pointer -> clang_getPointeeType(this).asType().map { Type.Ptr(it) }
        CXType_Record  -> TODO()
        CXType_Enum    -> TODO()
        CXType_Typedef -> TODO()
        CXType_ConstantArray ->
            clang_getArrayElementType(this)
                .asType()
                .map { Type.Array(it, Optional.of(clang_getArraySize(this))) }
        CXType_IncompleteArray ->
            clang_getArrayElementType(this)
                .asType()
                .map { Type.Array(it) }

        // others that could occur in C?

        else -> "Could not parse type of kind '${this.kind()}'".left()
    }