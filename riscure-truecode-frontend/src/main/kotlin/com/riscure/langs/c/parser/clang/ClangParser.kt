package com.riscure.langs.c.parser.clang

import arrow.core.left
import arrow.core.right
import com.riscure.langs.c.parser.Parser
import com.riscure.langs.c.parser.Result
import com.riscure.tc.codeanalysis.clang.ast.loader.ClangParsingResult
import org.bytedeco.javacpp.BytePointer
import org.bytedeco.javacpp.PointerPointer
import org.bytedeco.llvm.clang.CXIndex
import org.bytedeco.llvm.clang.CXTranslationUnit
import org.bytedeco.llvm.global.clang
import java.io.File

/**
 * This implements the parser interface using the Bytedeco library to call
 * into libclang to parse a C file.
 *
 * This is *not* thread-safe, as far as we know because Bytedeco is not thread-safe.
 */
class ClangParser : Parser<ClangUnitState> {

    override fun parse(file: File): Result<ClangUnitState> {
        val args: Array<String> = arrayOf("")

        // We allocate the arguments.
        val c_index: CXIndex = clang.clang_createIndex(0, 0)
        val c_tu = CXTranslationUnit()
        val c_sourceFile = BytePointer(file.absolutePath.toString())
        val c_arg_pointers = args.map { BytePointer(it) }
        val c_args = PointerPointer<BytePointer>(args.size.toLong())
        val c_parseOptions = clang.CXTranslationUnit_SingleFileParse

        c_arg_pointers.forEach { c_args.put(it) }

        // Define the deallocator
        fun free() {
            clang.clang_disposeIndex(c_index)
            c_sourceFile.close()
            c_arg_pointers.forEach { it.deallocate() }
            c_args.deallocate()
            // We don't free c_tu, because that will be part of the unit state.
        }

        // Parse the given file, storing the result in c_tu
        val code: Int =
            clang.clang_parseTranslationUnit2(c_index, c_sourceFile, c_args, args.size, null, 0, c_parseOptions, c_tu)

        try {
            // Interpret the result code generated by clang:
            val result = ClangParsingResult.fromCode(code)
            return if (result != ClangParsingResult.Success) {
                result.message.left()
            } else ClangUnitState(c_tu).right()
        }
        catch (e : Exception) {
            // if something went wrong, we do have to free the tu
            c_tu.close()

            return "Failed to parse translation unit: ${e.message}".left()
        }
        finally {
            // regardless of success, we free the auxiliary data
            free()
        }
    }
}