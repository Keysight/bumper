package com.riscure.bumper.libclang

import arrow.core.*
import com.riscure.dobby.clang.*
import com.riscure.bumper.index.TUID
import com.riscure.bumper.parser.Parser
import org.bytedeco.javacpp.BytePointer
import org.bytedeco.javacpp.PointerPointer
import org.bytedeco.llvm.clang.*
import org.bytedeco.llvm.global.clang.*
import java.io.File

/**
 * This implements the parser interface using the Bytedeco library to call
 * into libclang to parse a C file.
 *
 * This is *not* thread-safe, as far as we know because Bytedeco is not thread-safe.
 */
class ClangParser : Parser<CXCursor, CXCursor, ClangUnitState> {

    override fun parse(file: File, opts: Options, tuid: TUID): Either<Throwable, ClangUnitState> {
        val warnErrors   = Arg
            .reads("-Werror=${badWarnings.joinToString(separator = ",")}")
            .getOrHandle { throw RuntimeException("Invariant violation: bad clang options") }

        val cmd: Command = with(Spec.clang11) {
            Command(opts + warnErrors, listOf())
        }
        val args = cmd.toArguments()

        // We allocate the arguments.
        val c_index: CXIndex = clang_createIndex(0, 0)
        val c_tu = CXTranslationUnit()
        val c_sourceFile = BytePointer(file.absolutePath.toString())
        val c_arg_pointers = args.map { BytePointer(it) }
        val c_args = PointerPointer<BytePointer>(args.size.toLong())
        val c_parseOptions = CXTranslationUnit_SingleFileParse

        c_arg_pointers.forEach { c_args.put(it) }

        // Define the deallocator
        fun free() {
            clang_disposeIndex(c_index)
            c_sourceFile.close()
            c_arg_pointers.forEach { it.deallocate() }
            c_args.deallocate()
            // We don't free c_tu, because that will be part of the unit state.
        }

        // Parse the given file, storing the result in c_tu
        val code: Int =
            // This is the libclang version of clang -fsyntax-only, which performs preprocessing, parsing,
            // and type checking. It ignores -o and -emit-ast by default.
            // Despite the fact that `clang-11 -E` does not seem to imply `-O0` (it does some inlining),
            // this API call does imply it.
            clang_parseTranslationUnit2(c_index, c_sourceFile, c_args, args.size, null, 0, c_parseOptions, c_tu)

        try {
            // Interpret the result code generated by clang:
            val result = errorCodes[code]!!
            if (result != ClangError.Success) {
                return Parser.Error(file, result.msg).left()
            }

            // now check the diagnostics for errors
            val c_diagnostics = clang_getDiagnosticSetFromTU(c_tu)
            val errors = (0..clang_getNumDiagnosticsInSet(c_diagnostics))
                .map { clang_getDiagnosticInSet(c_diagnostics, it) }
                .filter { clang_getDiagnosticSeverity(it).let { sev ->
                    // fail on errors or fatal errors
                    sev == CXDiagnostic_Error || sev == CXDiagnostic_Fatal
                }}
                .map { clang_getDiagnosticSpelling(it).string }

            return if (errors.size > 0) {
                Parser.Error(
                    file,
                    "Translation unit has error diagnostics:\n" +
                            errors.joinToString("\n") { "- ${it}" }
                ).left()
            } else ClangUnitState(tuid, c_tu).right()
        }
        catch (e : Exception) {
            // if something went wrong, we do have to free the tu
            c_tu.close()

            return Parser.Error(file, e.message!!).left()
        }
        finally {
            // regardless of success, we free the auxiliary data
            free()
        }
    }

    companion object {
        private val spec = Spec.clang11

        val badWarnings = listOf("missing-declarations")

        val errorCodes: Map<Int, ClangError> = ClangError.values().associateBy { it.code }

        enum class ClangError(val code: Int, val msg: String) {
            Success(CXError_Success, "No error."),
            Failure(CXError_Failure, "A generic error code, no further details are available."),
            Crashed(CXError_Crashed, "libclang crashed while performing the requested operation"),
            InvalidArguments(CXError_InvalidArguments, "The function detected that the arguments violate the function contract."),
            ASTReadError(CXError_ASTReadError, "An AST deserialization error has occurred.");
        }
    }
}
